"""LLM integration for soft state management."""

import json
from abc import ABC, abstractmethod
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field

from .entities import GameWorld, Player, Team, ClubOwner, MediaOutlet, PlayerAgent, StaffMember
from .events import Event, MatchEvent


def analyze_match_events_for_story(match_events: List[MatchEvent], world: GameWorld) -> Dict[str, Any]:
    """Analyze match events to extract key storylines for media reports."""
    storylines = {
        "goals": [],
        "cards": [],
        "substitutions": [],
        "scorers": {},  # player_name: goal_count
        "assisters": {},  # player_name: assist_count
        "red_cards": [],
        "multiple_goals": [],  # players with 2+ goals
        "key_events": []
    }
    
    for event in match_events:
        if event.event_type == "Goal":
            # Track goal scorer
            if event.scorer in storylines["scorers"]:
                storylines["scorers"][event.scorer] += 1
            else:
                storylines["scorers"][event.scorer] = 1
            
            # Track assister
            if hasattr(event, 'assist') and event.assist:
                if event.assist in storylines["assisters"]:
                    storylines["assisters"][event.assist] += 1
                else:
                    storylines["assisters"][event.assist] = 1
            
            storylines["goals"].append({
                "scorer": event.scorer,
                "team": event.team,
                "minute": event.minute,
                "assist": getattr(event, 'assist', None)
            })
            
        elif event.event_type == "RedCard":
            storylines["red_cards"].append({
                "player": event.player,
                "team": event.team,
                "minute": event.minute,
                "reason": event.reason
            })
            storylines["cards"].append(event)
            
        elif event.event_type == "YellowCard":
            storylines["cards"].append(event)
            
        elif event.event_type == "Substitution":
            storylines["substitutions"].append({
                "team": event.team,
                "player_off": event.player_off,
                "player_on": event.player_on,
                "minute": event.minute
            })
    
    # Identify players with multiple goals
    for player, goals in storylines["scorers"].items():
        if goals >= 2:
            storylines["multiple_goals"].append({"player": player, "goals": goals})
    
    return storylines


class SoftStateUpdate(BaseModel):
    """Represents an update to soft state from LLM analysis."""
    entity_type: str  # "player", "team", "club_owner", "media_outlet", "player_agent", "staff_member"
    entity_id: str
    updates: Dict[str, Any]
    reasoning: str = Field(description="LLM's reasoning for the changes")


class MediaStory(BaseModel):
    """Represents a media story generated by an outlet."""
    media_outlet_id: str
    headline: str
    story_type: str = Field(default="match_report", description="Type of story")
    entities_mentioned: List[str] = Field(default_factory=list, description="IDs of players, teams, etc. mentioned")
    sentiment: int = Field(ge=-100, le=100, description="Story sentiment (-100 negative, 100 positive)")
    content: Optional[str] = Field(default=None, description="Full story content")
    importance: str = Field(default="normal", description="Match importance level")


class LLMProvider(ABC):
    """Abstract base class for LLM providers."""
    
    @abstractmethod
    async def analyze_match_events(
        self, 
        match_events: List[MatchEvent], 
        world: GameWorld
    ) -> List[SoftStateUpdate]:
        """Analyze match events and propose soft state updates."""
        pass
    
    @abstractmethod
    async def analyze_season_progress(
        self, 
        world: GameWorld
    ) -> List[SoftStateUpdate]:
        """Analyze overall season progress and propose updates."""
        pass
    
    @abstractmethod
    async def generate_career_summary(
        self, 
        player_id: str, 
        world: GameWorld
    ) -> str:
        """Generate a career summary for a specific player."""
        pass
    
    @abstractmethod
    async def generate_match_reports(
        self,
        match_events: List[MatchEvent],
        world: GameWorld,
        importance: str
    ) -> List[MediaStory]:
        """Generate match reports from media outlets for important matches."""
        pass


class MockLLMProvider(LLMProvider):
    """Mock LLM provider for testing and development."""
    
    async def analyze_match_events(
        self, 
        match_events: List[MatchEvent], 
        world: GameWorld
    ) -> List[SoftStateUpdate]:
        """Mock analysis that makes simple changes based on match events."""
        updates = []
        
        # Track goals and cards for each player
        player_stats = {}
        
        for event in match_events:
            if hasattr(event, 'scorer') and event.scorer:
                # Goal scorer gets form boost
                player_id = self._find_player_by_name(event.scorer, world)
                if player_id:
                    updates.append(SoftStateUpdate(
                        entity_type="player",
                        entity_id=player_id,
                        updates={"form": min(100, self._get_player_form(player_id, world) + 5)},
                        reasoning=f"Form boost for scoring a goal in minute {event.minute}"
                    ))
            
            if hasattr(event, 'player') and hasattr(event, 'reason'):
                # Player with card gets morale/form decrease
                player_id = self._find_player_by_name(event.player, world)
                if player_id and "Red" in event.__class__.__name__:
                    updates.append(SoftStateUpdate(
                        entity_type="player",
                        entity_id=player_id,
                        updates={
                            "form": max(1, self._get_player_form(player_id, world) - 10),
                            "morale": max(1, self._get_player_morale(player_id, world) - 15)
                        },
                        reasoning=f"Form and morale decrease for receiving red card: {event.reason}"
                    ))
        
        return updates
    
    async def analyze_season_progress(
        self, 
        world: GameWorld
    ) -> List[SoftStateUpdate]:
        """Mock season analysis that adjusts team morale based on league position."""
        updates = []
        
        for league_id, league in world.leagues.items():
            table = world.get_league_table(league_id)
            
            for position, team in enumerate(table, 1):
                # Top teams get morale boost, bottom teams get decrease
                current_morale = team.team_morale
                
                if position <= 3:  # Top 3
                    new_morale = min(100, current_morale + 2)
                    reasoning = f"Morale boost for being in top 3 (position {position})"
                elif position >= len(table) - 2:  # Bottom 3
                    new_morale = max(1, current_morale - 3)
                    reasoning = f"Morale decrease for being in bottom 3 (position {position})"
                else:
                    continue  # Mid-table teams unchanged
                
                updates.append(SoftStateUpdate(
                    entity_type="team",
                    entity_id=team.id,
                    updates={"team_morale": new_morale},
                    reasoning=reasoning
                ))
                
                # Update club owners based on team performance
                owners = world.get_club_owners_for_team(team.id)
                for owner in owners:
                    if position <= 3:  # Good performance
                        new_patience = min(100, owner.patience + 1)
                        new_approval = min(100, owner.public_approval + 3)
                        updates.append(SoftStateUpdate(
                            entity_type="club_owner",
                            entity_id=owner.id,
                            updates={"patience": new_patience, "public_approval": new_approval},
                            reasoning=f"Owner satisfaction from team's good performance (position {position})"
                        ))
                    elif position >= len(table) - 2:  # Poor performance
                        new_patience = max(1, owner.patience - 2)
                        new_approval = max(1, owner.public_approval - 5)
                        updates.append(SoftStateUpdate(
                            entity_type="club_owner",
                            entity_id=owner.id,
                            updates={"patience": new_patience, "public_approval": new_approval},
                            reasoning=f"Owner frustration from team's poor performance (position {position})"
                        ))
                
                # Update staff morale based on team performance
                staff = world.get_staff_for_team(team.id)
                for staff_member in staff:
                    if position <= 5:  # Good performance
                        new_morale = min(100, staff_member.morale + 1)
                        new_rapport = min(100, staff_member.team_rapport + 1)
                        updates.append(SoftStateUpdate(
                            entity_type="staff_member",
                            entity_id=staff_member.id,
                            updates={"morale": new_morale, "team_rapport": new_rapport},
                            reasoning=f"Staff satisfaction from team's good performance"
                        ))
                    elif position >= len(table) - 3:  # Poor performance
                        new_morale = max(1, staff_member.morale - 2)
                        updates.append(SoftStateUpdate(
                            entity_type="staff_member",
                            entity_id=staff_member.id,
                            updates={"morale": new_morale},
                            reasoning=f"Staff concern from team's poor performance"
                        ))
        
        # Update media narratives based on interesting stories
        for outlet in world.media_outlets.values():
            # Occasionally generate new stories or update sensationalism
            import random
            if random.random() < 0.3:  # 30% chance to update
                new_sensationalism = max(1, min(100, outlet.sensationalism + random.randint(-5, 5)))
                updates.append(SoftStateUpdate(
                    entity_type="media_outlet",
                    entity_id=outlet.id,
                    updates={"sensationalism": new_sensationalism},
                    reasoning="Media outlet adjusting editorial stance based on market response"
                ))
        
        # Update player agents' reputation based on client performance
        for agent in world.player_agents.values():
            if agent.clients:
                total_form = 0
                client_count = 0
                for client_id in agent.clients:
                    player = world.get_player_by_id(client_id)
                    if player:
                        total_form += player.form
                        client_count += 1
                
                if client_count > 0:
                    avg_form = total_form / client_count
                    if avg_form > 70:  # Clients performing well
                        new_reputation = min(100, agent.reputation + 1)
                        updates.append(SoftStateUpdate(
                            entity_type="player_agent",
                            entity_id=agent.id,
                            updates={"reputation": new_reputation},
                            reasoning="Agent reputation boost from client success"
                        ))
                    elif avg_form < 40:  # Clients struggling
                        new_reputation = max(1, agent.reputation - 1)
                        updates.append(SoftStateUpdate(
                            entity_type="player_agent",
                            entity_id=agent.id,
                            updates={"reputation": new_reputation},
                            reasoning="Agent reputation decline from client struggles"
                        ))
        
        return updates
    
    def _find_player_by_name(self, name: str, world: GameWorld) -> Optional[str]:
        """Find a player ID by name."""
        for player_id, player in world.players.items():
            if player.name == name:
                return player_id
        return None
    
    def _get_player_form(self, player_id: str, world: GameWorld) -> int:
        """Get current player form."""
        player = world.get_player_by_id(player_id)
        return player.form if player else 50
    
    def _get_player_morale(self, player_id: str, world: GameWorld) -> int:
        """Get current player morale."""
        player = world.get_player_by_id(player_id)
        return player.morale if player else 50
    
    async def generate_career_summary(
        self, 
        player_id: str, 
        world: GameWorld
    ) -> str:
        """Generate a mock career summary for a specific player."""
        player = world.get_player_by_id(player_id)
        if not player:
            return "Player not found."
        
        # Find the player's current team
        current_team = None
        for team in world.teams.values():
            if any(p.id == player_id for p in team.players):
                current_team = team
                break
        
        # Generate a simple mock career summary
        team_name = current_team.name if current_team else "Unknown Team"
        
        # Create mock career narrative based on player attributes
        if player.overall_rating >= 80:
            talent_level = "exceptional talent"
        elif player.overall_rating >= 70:
            talent_level = "skilled professional"
        elif player.overall_rating >= 60:
            talent_level = "solid contributor"
        else:
            talent_level = "developing player"
        
        # Create position-specific narrative
        position_desc = ""
        if player.position.value in ["ST", "LW", "RW"]:
            if player.shooting > 70:
                position_desc = f"Known for clinical finishing and goal-scoring instinct, {player.name} has been a reliable attacking threat."
            else:
                position_desc = f"{player.name} brings pace and movement to the attack, creating opportunities for teammates."
        elif player.position.value in ["CM", "CAM", "CDM"]:
            if player.passing > 80:
                position_desc = f"A creative midfield maestro, {player.name} orchestrates play with precise passing and vision."
            else:
                position_desc = f"{player.name} provides energy and work rate in the middle of the park."
        elif player.position.value in ["CB", "LB", "RB"]:
            if player.defending > 70:
                position_desc = f"A defensive stalwart, {player.name} has been a cornerstone of the team's backline."
            else:
                position_desc = f"{player.name} offers pace and athleticism in defense."
        elif player.position.value == "GK":
            position_desc = f"Between the posts, {player.name} has shown reliability and command of the penalty area."
        else:
            position_desc = f"{player.name} has been a versatile player capable of adapting to different roles."
        
        # Form-based recent performance
        form_desc = ""
        if player.form > 70:
            form_desc = "Currently in excellent form and playing with confidence."
        elif player.form > 50:
            form_desc = "Showing steady form and consistency in recent performances."
        else:
            form_desc = "Working to regain peak form and match sharpness."
        
        summary = f"""At {player.age} years old, {player.name} is a {talent_level} playing as a {player.position.value} for {team_name}. 

{position_desc}

{form_desc} With an overall rating of {player.overall_rating}, {player.name} continues to be an important part of the squad, bringing experience and determination to every match.

The {player.position.value} has maintained good fitness levels and remains committed to contributing to the team's success this season."""
        
        return summary
    
    async def generate_match_reports(
        self,
        match_events: List[MatchEvent],
        world: GameWorld,
        importance: str
    ) -> List[MediaStory]:
        """Generate mock match reports for important matches that have been completed."""
        if importance == "normal":
            # Don't generate reports for normal matches
            return []
        
        # Get match information from events
        match_id = None
        home_score = 0
        away_score = 0
        home_team_id = None
        away_team_id = None
        match_ended = False
        
        for event in match_events:
            if hasattr(event, 'match_id'):
                match_id = event.match_id
            if hasattr(event, 'home_score') and hasattr(event, 'away_score'):
                home_score = event.home_score
                away_score = event.away_score
            # Check if match has actually ended
            if event.event_type == "MatchEnded":
                match_ended = True
        
        if not match_id:
            return []
        
        # CRITICAL SAFEGUARD FOR ISSUE #56: Only generate reports for matches that have actually ended
        # This prevents fictitious match reports from being displayed when first launching the game
        # Before any matches are simulated, match_ended will be False and no reports will be generated
        if not match_ended:
            return []
        
        # Find the match to get team information
        match = world.get_match_by_id(match_id)
        if not match:
            return []
        
        home_team = world.get_team_by_id(match.home_team_id)
        away_team = world.get_team_by_id(match.away_team_id)
        
        if not home_team or not away_team:
            return []
        
        # Analyze match events to extract interesting storylines
        storylines = analyze_match_events_for_story(match_events, world)
        
        # Generate reports from a subset of media outlets
        stories = []
        outlets = list(world.media_outlets.values())
        
        # Select outlets based on importance
        num_outlets = min(3 if importance in ["title_race", "derby"] else 2, len(outlets))
        selected_outlets = outlets[:num_outlets]
        
        for outlet in selected_outlets:
            # Determine match result
            if home_score > away_score:
                winner = home_team.name
                loser = away_team.name
                winning_team_id = home_team.id
                result_desc = f"{home_score}-{away_score} victory"
            elif away_score > home_score:
                winner = away_team.name
                loser = home_team.name
                winning_team_id = away_team.id
                result_desc = f"{away_score}-{home_score} victory"
            else:
                result_desc = f"{home_score}-{away_score} draw"
                winner = None
                loser = None
                winning_team_id = None
            
            # Generate enhanced headlines based on match events
            headline = self._generate_enhanced_headline(
                storylines, home_team, away_team, winner, loser, 
                home_score, away_score, importance, winning_team_id, world
            )
            
            # Calculate sentiment based on outlet bias and result
            sentiment = 0
            home_bias = outlet.bias_towards_teams.get(home_team.id, 0)
            away_bias = outlet.bias_towards_teams.get(away_team.id, 0)
            
            if home_score > away_score:
                sentiment = home_bias - away_bias
            elif away_score > home_score:
                sentiment = away_bias - home_bias
            else:
                sentiment = (home_bias + away_bias) // 2
            
            # Clamp sentiment
            sentiment = max(-100, min(100, sentiment))
            
            # Create the story
            story = MediaStory(
                media_outlet_id=outlet.id,
                headline=headline,
                story_type="match_report",
                entities_mentioned=[home_team.id, away_team.id],
                sentiment=sentiment,
                importance=importance
            )
            
            stories.append(story)
        
        return stories
    
    def _generate_enhanced_headline(
        self, 
        storylines: Dict[str, Any], 
        home_team, 
        away_team, 
        winner: Optional[str], 
        loser: Optional[str], 
        home_score: int, 
        away_score: int, 
        importance: str,
        winning_team_id: Optional[str],
        world
    ) -> str:
        """Generate enhanced headline using match event details."""
        
        # Check for rivalry information
        rivalry = world.get_rivalry_between_teams(home_team.id, away_team.id) if world else None
        
        # Check for multiple goal scorers (braces, hat-tricks)
        if storylines["multiple_goals"]:
            top_scorer = max(storylines["multiple_goals"], key=lambda x: x["goals"])
            if top_scorer["goals"] >= 3:
                if rivalry:
                    return f"{top_scorer['player']}'s hat-trick powers {winner} to {rivalry.name} triumph"
                return f"{top_scorer['player']}'s hat-trick powers {winner} to {home_score}-{away_score} {importance} triumph"
            elif top_scorer["goals"] == 2:
                if rivalry:
                    return f"{top_scorer['player']}'s brace decides {rivalry.name} in {winner}'s favor"
                return f"{top_scorer['player']}'s brace leads {winner} to {home_score}-{away_score} {importance} victory"
        
        # Check for red card drama
        if storylines["red_cards"]:
            red_card_info = storylines["red_cards"][0]  # Focus on first red card
            if winner:
                if rivalry:
                    return f"{winner} capitalizes on red card to win {rivalry.name} derby"
                return f"{winner} capitalizes on red card to defeat 10-man {loser} {home_score}-{away_score}"
            else:
                if rivalry:
                    return f"Ten-man drama mars {rivalry.name} as both sides share points"
                return f"Ten-man drama as {home_team.name} and {away_team.name} share points in {home_score}-{away_score} draw"
        
        # Check for goal scorer mentions
        if storylines["goals"] and winner:
            # Find a goal scorer from the winning team
            winning_goals = [g for g in storylines["goals"] if g["team"] == winning_team_id]
            if winning_goals:
                scorer = winning_goals[0]["scorer"]
                if importance == "derby" and rivalry:
                    return f"{scorer} strikes as {winner} claims {rivalry.name} bragging rights"
                elif importance == "derby":
                    return f"{scorer} strikes as {winner} claims local bragging rights in derby triumph"
                elif importance == "title_race":
                    return f"{scorer} nets crucial goal as {winner} takes step towards title"
                elif importance == "relegation":
                    return f"{scorer}'s strike gives {winner} vital win in relegation battle"
                else:
                    return f"{scorer} stars in {winner}'s {home_score}-{away_score} victory over {loser}"
        
        # Fallback to importance-based headlines (original logic)
        if importance == "title_race":
            if winner:
                return f"{winner} takes crucial step in title race with {home_score}-{away_score} victory over {loser}"
            else:
                return f"Title race tightens as {home_team.name} and {away_team.name} share points"
        elif importance == "derby":
            if rivalry:
                if winner:
                    return f"{winner} claims {rivalry.name} bragging rights with {home_score}-{away_score} victory"
                else:
                    return f"Honors even in thrilling {rivalry.name} encounter"
            else:
                if winner:
                    return f"{winner} claims local bragging rights in derby triumph"
                else:
                    return f"Honors even in hard-fought local derby"
        elif importance == "relegation":
            if winner:
                return f"{winner} strikes crucial blow in relegation battle"
            else:
                return f"Vital points shared in relegation six-pointer"
        else:  # high importance
            if winner:
                return f"{winner} secures important {home_score}-{away_score} victory in high-stakes encounter"
            else:
                return f"High-stakes clash ends in stalemate"


class SoftStateValidator:
    """Validates and clamps LLM-proposed soft state updates."""
    
    def validate_update(self, update: SoftStateUpdate, world: GameWorld) -> bool:
        """Validate that an update is valid and safe to apply."""
        if update.entity_type == "player":
            return self._validate_player_update(update, world)
        elif update.entity_type == "team":
            return self._validate_team_update(update, world)
        elif update.entity_type == "club_owner":
            return self._validate_club_owner_update(update, world)
        elif update.entity_type == "media_outlet":
            return self._validate_media_outlet_update(update, world)
        elif update.entity_type == "player_agent":
            return self._validate_player_agent_update(update, world)
        elif update.entity_type == "staff_member":
            return self._validate_staff_member_update(update, world)
        return False
    
    def _validate_player_update(self, update: SoftStateUpdate, world: GameWorld) -> bool:
        """Validate a player update."""
        player = world.get_player_by_id(update.entity_id)
        if not player:
            return False
        
        # Clamp all values to valid ranges
        for key, value in update.updates.items():
            if key in ["form", "morale", "fitness"]:
                if not isinstance(value, (int, float)) or value < 1 or value > 100:
                    return False
        
        return True
    
    def _validate_team_update(self, update: SoftStateUpdate, world: GameWorld) -> bool:
        """Validate a team update."""
        team = world.get_team_by_id(update.entity_id)
        if not team:
            return False
        
        # Clamp all values to valid ranges
        for key, value in update.updates.items():
            if key in ["team_morale", "tactical_familiarity"]:
                if not isinstance(value, (int, float)) or value < 1 or value > 100:
                    return False
        
        return True
    
    def _validate_club_owner_update(self, update: SoftStateUpdate, world: GameWorld) -> bool:
        """Validate a club owner update."""
        owner = world.get_club_owner_by_id(update.entity_id)
        if not owner:
            return False
        
        # Clamp all values to valid ranges
        for key, value in update.updates.items():
            if key in ["ambition", "patience", "public_approval"]:
                if not isinstance(value, (int, float)) or value < 1 or value > 100:
                    return False
        
        return True
    
    def _validate_media_outlet_update(self, update: SoftStateUpdate, world: GameWorld) -> bool:
        """Validate a media outlet update."""
        outlet = world.get_media_outlet_by_id(update.entity_id)
        if not outlet:
            return False
        
        # Clamp all values to valid ranges
        for key, value in update.updates.items():
            if key == "sensationalism":
                if not isinstance(value, (int, float)) or value < 1 or value > 100:
                    return False
            elif key == "bias_towards_teams":
                if not isinstance(value, dict):
                    return False
                for team_id, bias in value.items():
                    if not isinstance(bias, (int, float)) or bias < -100 or bias > 100:
                        return False
            elif key == "active_stories":
                if not isinstance(value, list):
                    return False
        
        return True
    
    def _validate_player_agent_update(self, update: SoftStateUpdate, world: GameWorld) -> bool:
        """Validate a player agent update."""
        agent = world.get_player_agent_by_id(update.entity_id)
        if not agent:
            return False
        
        # Clamp all values to valid ranges
        for key, value in update.updates.items():
            if key in ["reputation", "aggressiveness"]:
                if not isinstance(value, (int, float)) or value < 1 or value > 100:
                    return False
            elif key == "clients":
                if not isinstance(value, list):
                    return False
        
        return True
    
    def _validate_staff_member_update(self, update: SoftStateUpdate, world: GameWorld) -> bool:
        """Validate a staff member update."""
        staff = world.get_staff_member_by_id(update.entity_id)
        if not staff:
            return False
        
        # Clamp all values to valid ranges
        for key, value in update.updates.items():
            if key in ["morale", "team_rapport"]:
                if not isinstance(value, (int, float)) or value < 1 or value > 100:
                    return False
        
        return True
    
    def apply_update(self, update: SoftStateUpdate, world: GameWorld) -> bool:
        """Apply a validated update to the world state."""
        if not self.validate_update(update, world):
            return False
        
        if update.entity_type == "player":
            player = world.get_player_by_id(update.entity_id)
            if player:
                for key, value in update.updates.items():
                    if hasattr(player, key):
                        setattr(player, key, value)
                return True
        
        elif update.entity_type == "team":
            team = world.get_team_by_id(update.entity_id)
            if team:
                for key, value in update.updates.items():
                    if hasattr(team, key):
                        setattr(team, key, value)
                return True
        
        elif update.entity_type == "club_owner":
            owner = world.get_club_owner_by_id(update.entity_id)
            if owner:
                for key, value in update.updates.items():
                    if hasattr(owner, key):
                        setattr(owner, key, value)
                return True
        
        elif update.entity_type == "media_outlet":
            outlet = world.get_media_outlet_by_id(update.entity_id)
            if outlet:
                for key, value in update.updates.items():
                    if hasattr(outlet, key):
                        setattr(outlet, key, value)
                return True
        
        elif update.entity_type == "player_agent":
            agent = world.get_player_agent_by_id(update.entity_id)
            if agent:
                for key, value in update.updates.items():
                    if hasattr(agent, key):
                        setattr(agent, key, value)
                return True
        
        elif update.entity_type == "staff_member":
            staff = world.get_staff_member_by_id(update.entity_id)
            if staff:
                for key, value in update.updates.items():
                    if hasattr(staff, key):
                        setattr(staff, key, value)
                return True
        
        return False


class BrainOrchestrator:
    """Orchestrates LLM analysis and soft state updates."""
    
    def __init__(self, llm_provider: LLMProvider, validator: Optional[SoftStateValidator] = None) -> None:
        self.llm_provider = llm_provider
        self.validator = validator or SoftStateValidator()
    
    async def process_match_events(
        self, 
        match_events: List[MatchEvent], 
        world: GameWorld
    ) -> List[SoftStateUpdate]:
        """Process match events through LLM and apply valid updates."""
        proposed_updates = await self.llm_provider.analyze_match_events(match_events, world)
        
        applied_updates = []
        for update in proposed_updates:
            if self.validator.apply_update(update, world):
                applied_updates.append(update)
        
        return applied_updates
    
    async def process_season_progress(self, world: GameWorld) -> List[SoftStateUpdate]:
        """Process season progress through LLM and apply valid updates."""
        proposed_updates = await self.llm_provider.analyze_season_progress(world)
        
        applied_updates = []
        for update in proposed_updates:
            if self.validator.apply_update(update, world):
                applied_updates.append(update)
        
        return applied_updates
    
    async def process_match_reports(
        self, 
        match_events: List[MatchEvent], 
        world: GameWorld,
        importance: str
    ) -> List[MediaStory]:
        """Generate match reports for important matches."""
        return await self.llm_provider.generate_match_reports(match_events, world, importance)